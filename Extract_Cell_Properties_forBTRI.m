function [cell_properties] = Extract_Cell_Properties_forBTRI(cellList,objects_name, varargin)
%{
-About-
Function to extract properties of individual cells from cellLists generated
by Oufti.

-Inputs-
cellList:  cellList generated by Oufti, loaded into matlab. 
            
objects_name:   name used to store information for detected objects (using
                Oufti's objectDetection module). Typically this is 'object'
                or 'nucleoiddata'. Enter 'none' in case no objects were
                detected
 
-varargin-
    'pixel_size':   pixel size, image resolution. If not specified, default
                    pixel size of 0.07 micron per pixel will be used

-Outputs-
cell_properties:    array in which each row corresponds to a cell and each
                    column to a different cellular property. The column
                    order is: 
                    1: frame
                    2: cell number
                    3: cell length (micron)
                    4: cell width (micron)
                    5: cell area (squared micron)
                    6: cell volume (cubic micron)
                    7: surface area (squared micron)
                    8: surface area over volume (micron-1)
                    9: total nucleoid length (micron)
                    10: total nucleoid width (micron)
                    11: total nucleoid area (squared micron)
                    12: total nucleoid volume (cubic micron)
                    13: NC ratio (calculated based on area)
                    14: rel position of global nucleoid centroid
                    15: number of nucleoids
                    16: nucleoid length ratio (if 2 separate nucleoid)
                    17: nucleoid width ratio (if 2 separate nucleoid)
                    18: nucleoid area ratio (if 2 separate nucleoid)
                    19: nucleoid volume ratio (if 2 separate nucleoid)
                    20: rel position of separate nucleoid 1 (if 2 separate nucleoid)
                    21: rel position of separate nucleoid 2 (if 2 separate nucleoid)
                    22: cell constr (micron)
                    23: cell constriction position
                    24: nucleoid constr (micron)
                    25: nucleoid constr position
                    26: relative cell constr
                    27: relative nucleoid constr
                    28: total PA intensity
                    29: total PA concentration
                    30: cell orientation (1: PA on the right/end, 0: PA on the left/beginning)
                    31: localized PA intensity(PA intensity in 1/3rd of the cell where the PA is located)
                    32: localized PA concentration(PA intensity in 1/3rd of the cell where the PA is located)
                    33: minimum distance between 2 nucleoids (if 2 separate nucleoids)
                    34:peak in signal1



-Example-
NA

-Supplementary-
NA

-Keywords-
Cell properties, cell features, morphology, nucleoid, cellList, Oufti

-Dependencies-
edist (function to calculate euclidean distance between points in 2D)
constDegreeSingleCell
constDegreeSingleNucleoid
distancePointPolyline (from geom2D package)
model2mesh

-References-
NA

-Author-
Sander Govers, 22 October 2018
%}

%% Parse varargin input
tic
%if pixel size is not specified, use default pixel size of 0.064
%micron per pixel.
pixel_size=0.065;

%Examine whether pixel size was specified using varargin input
for k = 1:length(varargin)
    if strcmpi(varargin{k}, 'pixel_size')
        %if pixel size is specified, use this to extract cellular
        %information
        pixel_size = varargin{k+1};
        %Check if specified pixel size is a single number, throw error if
        %this is not the case
        if length(pixel_size) ~= 1
            error('argument for pixel size was incorrectly formed')        
        end
    end
end

%% Clean out cell entries in cellList that do not contain correct information

%Initiate counter to keep track of the number of removed cells
counter=0;
%Loop through frames and cells in the cellList
for ii=1:length(cellList.meshData)
    for jj=1:length(cellList.meshData{ii})
        %Remove empty entries, entries that do not contain cell mesh
        %information or very short entries
        if isempty(cellList.meshData{ii}{jj}) ||...
                ~isfield(cellList.meshData{ii}{jj},'mesh') ||...
                length(cellList.meshData{ii}{jj}.mesh)<=4
            cellList.meshData{ii}{jj}=[];
            %Add 1 to counter if cell entry is removed
            counter=counter+1;
        end
    end
end
%Display the total number of cell entries that was removed from the
%cellList
disp(['Number of cell entries cleaned out : ',num2str(counter)]);

%% Extract properties from individual cells

w = waitbar(0,'Data coming soon...');

%Generate return structure
tab = struct('frame',[],'cell_id',[],'cell_length',[],'cell_width',[],'cell_area',[],...
    'cell_volume',[],'cell_surface_area',[],'cell_surface_area_over_volume',[],...
    'nucleoid_length',[],'nucleoid_width',[],'nucleoid_area',[],'nucleoid_volume',[],'NC_ratio',[],...
    'rel_nucleoid_pos',[],'number_of_nucleoids',[],...
    'nucleoid_length_ratio',[],'nucleoid_width_ratio',[],'nucleoid_area_ratio',[],'nucleoid_volume_ratio',[],...
    'rel_pos_nucleoid1',[],'rel_pos_nucleoid2',[],'cell_constr',[],'cell_constr_pos',[],...
    'nucleoid_constr',[],'nucleoid_constr_pos',[],'rel_cell_constr',[],'rel_nucleoid_constr',[],...
    'total_PA_int',[],'total_PA_conc',[],'orientation',[],'local_PA_int',[],'local_PA_conc',[],...
    'minDist',[],'signal1_peak',[]);


%Loop through frames and cells in the cellList and extract all features
for ii=1:length(cellList.meshData)
    clear meshData tmpCell
    %Only do this for frames containing cells
    if ~isempty(cellList.meshData{ii})
        %Generate temporary structure to store data of current frame
        tmp_structure = struct('frame',[],'cell_id',[],'cell_length',[],'cell_width',[],'cell_area',[],...
            'cell_volume',[],'cell_surface_area',[],'cell_surface_area_over_volume',[],...
            'nucleoid_length',[],'nucleoid_width',[],'nucleoid_area',[],'nucleoid_volume',[],'NC_ratio',[],...
            'rel_nucleoid_pos',[],'number_of_nucleoids',[],...
            'nucleoid_length_ratio',[],'nucleoid_width_ratio',[],'nucleoid_area_ratio',[],'nucleoid_volume_ratio',[],...
            'rel_pos_nucleoid1',[],'rel_pos_nucleoid2',[],'cell_constr',[],'cell_constr_pos',[],...
            'nucleoid_constr',[],'nucleoid_constr_pos',[],'rel_cell_constr',[],'rel_nucleoid_constr',[],...
            'total_PA_int',[],'total_PA_conc',[],'orientation',[],'local_PA_int',[],'local_PA_conc',[],...
            'minDist',[],'signal1_peak',[]);
        
        %for shorter notation
        mesh_data = cellList.meshData{ii};
        
        %Loop through all cells in the current frame
        for jj=1:length(mesh_data)
            if ~isempty(mesh_data{jj})
                % Extract frame number and cell ids
                tmp_structure(jj).frame = ii;
                tmp_structure(jj).cell_id = cellList.cellId{ii}(jj);
            
                % Extract cell length from cell mesh information
                cell_mesh=double(mesh_data{jj}.mesh);

                %Calculate the distance between each cell segment
                step_length = edist(cell_mesh(2:end,1)+cell_mesh(2:end,3),cell_mesh(2:end,2)+cell_mesh(2:end,4),...
                    cell_mesh(1:end-1,1)+cell_mesh(1:end-1,3),cell_mesh(1:end-1,2)+cell_mesh(1:end-1,4))/2;
                %Use the sum of distances to calculate total cell length
                tmp_structure(jj).cell_length = sum(step_length)*pixel_size;

                % Cell width
                x1=cell_mesh(:,1);
                y1=cell_mesh(:,2);
                x2=cell_mesh(:,3);
                y2=cell_mesh(:,4);
                width = sort(sqrt((x1-x2).^2+(y1-y2).^2),'descend');
                %Calculate cell width based on the mean cell width of the
                %30% highest cell width measured across the cell contour
                tmp_structure(jj).cell_width = mean(width(1:floor(length(width)/3)))*pixel_size;

                % Cell area
                mesh_length = size(cell_mesh,1)-1;
                step_area=zeros(mesh_length,1);
                for counter=1:mesh_length
                    %Calculate the area of each cell segment
                    step_area(counter)=polyarea([cell_mesh(counter:counter+1,1);cell_mesh(counter+1:-1:counter,3)],...
                        [cell_mesh(counter:counter+1,2);cell_mesh(counter+1:-1:counter,4)]);
                end
                %Use the sum of areas to calculate total cell area
                tmp_structure(jj).cell_area = sum(step_area)*pixel_size*pixel_size;
                
                % Cell volume
                d = edist(cell_mesh(:,1),cell_mesh(:,2),cell_mesh(:,3),cell_mesh(:,4));
                %Calculate the volume of each cell segment
                step_volume = (d(1:end-1).*d(2:end) + (d(1:end-1)-d(2:end)).^2/3).*step_length*pi/4;
                %Use the sum of volumes to calculate total cell volume
                tmp_structure(jj).cell_volume = sum(step_volume)*pixel_size*pixel_size*pixel_size;
                
                % Surface area
                step_surface_area=zeros(length(cell_mesh)-1,1);
                for counter=1:length(cell_mesh)-1
                    %Calculate the surface area of each cell segment
                    step_surface_area(counter)=pdist2(cell_mesh(counter,1:2),cell_mesh(counter+1,1:2));
                end
                %Use the sum of surface area to calculate total cell
                %surface area
                tmp_structure(jj).cell_surface_area = sum(pi*step_surface_area.*(width(1:end-1)+width(2:end))./2)*pixel_size*pixel_size;
                
                % Surface area to volume ratio
                tmp_structure(jj).cell_surface_area_over_volume = tmp_structure(jj).cell_surface_area/tmp_structure(jj).cell_volume;
                
                %Cell constriction
                tmp_structure(jj).cell_constr=NaN;
                tmp_structure(jj).cell_constr_pos=NaN;
                tmp_structure(jj).rel_cell_constr=NaN;
                % In order to be able to run the constriction degree function
                mesh_data{jj}.lengthvector = cumsum(step_length)-step_length/2;
                mesh_data{jj}.length=sum(step_length);
                if isfield(mesh_data{jj},'signal0') && ~isempty(mesh_data{jj}.signal0)
                        [tmp_rel_const,tmp_divpos,~] = ...
                            constDegreeSingleCell(mesh_data{jj},pixel_size);
                    tmp_cell_constr=tmp_structure(jj).cell_width*tmp_rel_const*2.5;
                else
                    tmp_cell_constr=NaN;
                    tmp_rel_const=NaN;
                    tmp_divpos=NaN;
                end
                tmp_structure(jj).cell_constr=tmp_cell_constr;
                tmp_structure(jj).cell_constr_pos=tmp_divpos;
                tmp_structure(jj).rel_cell_constr=tmp_rel_const;
                
                % Fluo PA (signal1)
                tmp_structure(jj).total_PA_int=NaN;
                tmp_structure(jj).total_PA_conc=NaN;
                if isfield(mesh_data{jj},'signal1')
                    tmp_structure(jj).total_PA_int=sum(mesh_data{jj}.signal1);
                    tmp_structure(jj).total_PA_conc=tmp_structure(jj).total_PA_int/tmp_structure(jj).cell_area;
                end
                
                % Orientation
                tmp_structure(jj).orientation = NaN;
                if isfield(mesh_data{jj},'signal1')
                    ix50=round(length(mesh_data{jj}.signal1)*0.5);
                    %Cells with highest flourescence in second part have
                    %the correct orientation, whereas others dont
                    if max(mesh_data{jj}.signal1(1:ix50))<max(mesh_data{jj}.signal1(ix50:end))
                        tmp_structure(jj).orientation = 1;
                    else
                        tmp_structure(jj).orientation = 0;
                    end
                end
                
                %PA fluo in third of the cell that contains the PA
                tmp_structure(jj).local_PA_int=NaN;
                tmp_structure(jj).local_PA_conc=NaN;
                if isfield(mesh_data{jj},'signal1')
                    ix33=round(length(mesh_data{jj}.signal1)/3);
                    if tmp_structure(jj).orientation == 1
                        tmp_structure(jj).local_PA_int=sum(mesh_data{jj}.signal1(ix33*2:end));
                        tmp_structure(jj).local_PA_conc=tmp_structure(jj).local_PA_int/...
                            (sum(step_area(ix33*2:end))*pixel_size*pixel_size);
                    elseif tmp_structure(jj).orientation == 0
                        tmp_structure(jj).local_PA_int=sum(mesh_data{jj}.signal1(1:ix33));
                        tmp_structure(jj).local_PA_conc=tmp_structure(jj).local_PA_int/...
                            (sum(step_area(1:ix33))*pixel_size*pixel_size);
                    else
                        tmp_structure(jj).local_PA_int=NaN;
                        tmp_structure(jj).local_PA_conc=NaN;
                    end
                end
                
                % Extract nucleoid chracteristics
                % Set default values to NaN, in case no nucleoid were
                % detected or nucleoid detection failed for a certain cell
                tmp_structure(jj).nucleoid_length = NaN;
                tmp_structure(jj).nucleoid_width = NaN;
                tmp_structure(jj).nucleoid_area = NaN;
                tmp_structure(jj).nucleoid_volume = NaN;
                tmp_structure(jj).NC_ratio = NaN;
                tmp_structure(jj).rel_nucleoid_pos = NaN;
                tmp_structure(jj).number_of_nucleoids = NaN;
                tmp_structure(jj).nucleoid_length_ratio = NaN;
                tmp_structure(jj).nucleoid_width_ratio = NaN;
                tmp_structure(jj).nucleoid_area_ratio = NaN;
                tmp_structure(jj).nucleoid_volume_ratio = NaN;
                tmp_structure(jj).rel_pos_nucleoid1 = NaN;
                tmp_structure(jj).rel_pos_nucleoid2 = NaN;
                tmp_structure(jj).nucleoid_constr = NaN;
                tmp_structure(jj).nucleoid_constr_pos = NaN;
                tmp_structure(jj).rel_nucleoid_constr = NaN;
                tmp_structure(jj).minDist = NaN;
                
                %Check if nucleoid information is present in cell
                %properties, this is done using the objects name specified
                %by the user in the input of the function
                if isfield(mesh_data{jj},objects_name)
                   nucleoid_widths =[];
                   nucleoid_widths_separate =cell(1);
                   nucleoid_lengths =[];
                   nucleoid_volumes =[];
                   nucleoid_areas =[];
                   nucleoid_coordinates=[];
                   nucleoid_coordinates_separate=cell(1);
                   %Loop through individual nucleoids within a cell and
                   %store their properties
                    for piece=1:length(mesh_data{jj}.(objects_name).outlines)
                         nucleoid_coordinates=[nucleoid_coordinates;mesh_data{jj}.(objects_name).outlines{piece}];
                         nucleoid_coordinates_separate{piece}=mesh_data{jj}.(objects_name).outlines{piece};
                        %Nucleoid outlines have to be converted to mesh format to extract length, width, volume and
                            %absolute constriction
                            tmp_nucleoid_mesh=model2mesh(mesh_data{jj}.(objects_name).outlines{piece},1,0,50);
                            if  tmp_nucleoid_mesh~=0
                                %Nucleoid length
                                nucleoid_steplength = edist(tmp_nucleoid_mesh(2:end,1)+tmp_nucleoid_mesh(2:end,3),...
                                    tmp_nucleoid_mesh(2:end,2)+tmp_nucleoid_mesh(2:end,4),...
                                tmp_nucleoid_mesh(1:end-1,1)+tmp_nucleoid_mesh(1:end-1,3),...
                                tmp_nucleoid_mesh(1:end-1,2)+tmp_nucleoid_mesh(1:end-1,4))/2;
                                tmp_nucleoid_length = sum(nucleoid_steplength)*pixel_size;
                                nucleoid_lengths =[nucleoid_lengths; tmp_nucleoid_length];
                                % Nucleoid width
                                x1_nucleoid=tmp_nucleoid_mesh(:,1);
                                y1_nucleoid=tmp_nucleoid_mesh(:,2);
                                x2_nucleoid=tmp_nucleoid_mesh(:,3);
                                y2_nucleoid=tmp_nucleoid_mesh(:,4);
                                tmp_nucleoid_widths = sqrt((x1_nucleoid-x2_nucleoid).^2+(y1_nucleoid-y2_nucleoid).^2);
                                nucleoid_widths =[nucleoid_widths;tmp_nucleoid_widths];
                                nucleoid_widths_separate{piece}=tmp_nucleoid_widths;
                                % Nucleoid area
                                % Cell area
                                lng = size(tmp_nucleoid_mesh,1)-1;
                                nucleoid_steparea=zeros(lng,1);
                                for kk=1:lng
                                    nucleoid_steparea(kk)=polyarea([tmp_nucleoid_mesh(kk:kk+1,1);...
                                        tmp_nucleoid_mesh(kk+1:-1:kk,3)],...
                                        [tmp_nucleoid_mesh(kk:kk+1,2);tmp_nucleoid_mesh(kk+1:-1:kk,4)]);
                                end
                                tmp_nucleoid_area = sum(nucleoid_steparea)*pixel_size*pixel_size;
                                nucleoid_areas =[nucleoid_areas;tmp_nucleoid_area];
                                % Nucleoid volume
                                d = edist(tmp_nucleoid_mesh(:,1),tmp_nucleoid_mesh(:,2),...
                                    tmp_nucleoid_mesh(:,3),tmp_nucleoid_mesh(:,4));
                                nucleoid_stepvolume = (d(1:end-1).*d(2:end) + (d(1:end-1)-d(2:end)).^2/3).*nucleoid_steplength*pi/4;
                                tmp_nucleoid_volume = sum(nucleoid_stepvolume)*pixel_size*pixel_size*pixel_size;
                                nucleoid_volumes =[nucleoid_volumes;tmp_nucleoid_volume];
                            else
                                nucleoid_lengths =[nucleoid_lengths;NaN];
                                nucleoid_widths =[nucleoid_widths;NaN];
                                nucleoid_areas =[nucleoid_areas;NaN];
                                nucleoid_volumes =[nucleoid_volumes;NaN];
                            end 
                    end
                    %Calculate total nucleoid length, width, volume and
                    %write into data structure
                    if ~isempty(nucleoid_lengths)
                        tmp_structure(jj).nucleoid_length=sum(nucleoid_lengths);
                        nucleoid_widths_ordered = sort(nucleoid_widths,'descend');
                        tmp_structure(jj).nucleoid_width = nanmean(nucleoid_widths_ordered(1:floor(length(nucleoid_widths_ordered)/3)))*pixel_size;
                        tmp_structure(jj).nucleoid_area=sum(nucleoid_areas);
                        tmp_structure(jj).nucleoid_volume=sum(nucleoid_volumes);
                    end
                    %Divide nucleoid area by the cell area to obtain the NC
                    %ratio
                    tmp_structure(jj).NC_ratio = tmp_structure(jj).nucleoid_area/tmp_structure(jj).cell_area;
                    
                    %Determine number of nucleoids inside a cell
                    tmp_structure(jj).number_of_nucleoids = length(mesh_data{jj}.(objects_name).outlines);
                    
                    %Determine relative positioning of nucleoid centroid
                    %along a cell's length
                    if ~isempty(nucleoid_lengths)
                        nucleoid_centroid=nanmean(nucleoid_coordinates);
                        M = mesh_data{jj}.mesh;
                        X=double([M(:,1) (M(:,3))]);
                        Y=double([M(:,2) (M(:,4))]);
                        model=horzcat(X(:,1),Y(:,1),X(:,2),Y(:,2));
                        %Calculate centerline
                        centerLine = [(model(:,1)+model(:,3))/2 (model(:,2)+model(:,4))/2];
                                       %distancePointPolyline comes from geom2D package
                        [~, rel_pos] = distancePointPolyline(nucleoid_centroid, centerLine);
                        tmp_structure(jj).rel_nucleoid_pos=rel_pos/length(M);
                    end

                    %For cells with 2 nucleoids, extract morphological
                    %ratios to obtain info on potential differences between
                    %the 2 nucleoids present
                    %Also calculate the minimu distance between the 
                    if length(mesh_data{jj}.(objects_name).outlines)==2 && ~isnan(nucleoid_lengths(1)) && ~isnan(nucleoid_lengths(2))
                        tmp_structure(jj).nucleoid_length_ratio = nucleoid_lengths(1)/nucleoid_lengths(2);
                        tmp_structure(jj).nucleoid_area_ratio = nucleoid_areas(1)/nucleoid_areas(2);
                        tmp_structure(jj).nucleoid_volume_ratio = nucleoid_volumes(1)/nucleoid_volumes(2);
                        
                        nucleoid_widths_separate_1_ordered = sort(nucleoid_widths_separate{1},'descend');
                        nucleoid_width_separate_1 = nanmean(nucleoid_widths_separate_1_ordered(1:floor(length(nucleoid_widths_separate_1_ordered)/3)))*pixel_size;
                        nucleoid_widths_separate_2_ordered = sort(nucleoid_widths_separate{2},'descend');
                        nucleoid_width_separate_2 = nanmean(nucleoid_widths_separate_2_ordered(1:floor(length(nucleoid_widths_separate_2_ordered)/3)))*pixel_size;
                        tmp_structure(jj).nucleoid_width_ratio = nucleoid_width_separate_1/nucleoid_width_separate_2;
                        
                        nucleoid_centroid_1=nanmean(nucleoid_coordinates_separate{1});
                        [~, rel_pos_1] = distancePointPolyline(nucleoid_centroid_1, centerLine);
                        tmp_structure(jj).rel_pos_nucleoid1 = rel_pos_1/length(M);
                        nucleoid_centroid_2=nanmean(nucleoid_coordinates_separate{2});
                        [~, rel_pos_2] = distancePointPolyline(nucleoid_centroid_2, centerLine);
                        tmp_structure(jj).rel_pos_nucleoid2 = rel_pos_2/length(M);
                        
                        tmp_minDist=NaN(1,size(mesh_data{jj}.(objects_name).outlines{1},2));
                        for ss=1:length(mesh_data{jj}.(objects_name).outlines{1})
                            tmp_minDist(ss) = distancePointPolygon(mesh_data{jj}.(objects_name).outlines{1}(ss,:), ...
                                mesh_data{jj}.(objects_name).outlines{2});
                        end
                        tmp_structure(jj).minDist=min(tmp_minDist)*pixel_size;                                                   
                        
                    end
                    
                    %Nucleoid constriction
                    if isfield(mesh_data{jj},'signal1') && ~isempty(mesh_data{jj}.signal1) && sum(mesh_data{jj}.signal1)>0.1
                        [tmp_rel_nConst,tmp_ndivpos,~] = ...
                            constDegreeSingleNucleoid(mesh_data{jj},pixel_size);
                        tmp_nucl_constr=tmp_structure(jj).nucleoid_width*tmp_rel_nConst;
                    else
                        tmp_nucl_constr=NaN;
                        tmp_ndivpos=NaN; 
                        tmp_rel_nConst=NaN;
                    end
                    tmp_structure(jj).nucleoid_constr=tmp_nucl_constr;
                    tmp_structure(jj).nucleoid_constr_pos=tmp_ndivpos;
                    tmp_structure(jj).rel_nucleoid_constr=tmp_rel_nConst;
                    
                    
                end
                tmp_structure(jj).signal1_peak=NaN;
                if isfield(mesh_data{jj},'signal1') && ~isempty(mesh_data{jj}.signal1) && sum(mesh_data{jj}.signal1)>0.1
                    [~,sign_idx]=max(mesh_data{jj}.signal1);
                     tmp_structure(jj).signal1_peak=sign_idx/length(mesh_data{jj}.signal1);
                end
            end
        end

    tab=[tab,tmp_structure];
    waitbar(ii/length(cellList.meshData));
    end
end
tab(1)=[];
toc
close(w);
out = tab;

%Convert structure to array
tmp_array(:,1)=cat(1,tab.frame);
tmp_array(:,2)=cat(1,tab.cell_id);
tmp_array(:,3)=cat(1,tab.cell_length);
tmp_array(:,4)=cat(1,tab.cell_width);
tmp_array(:,5)=cat(1,tab.cell_area);
tmp_array(:,6)=cat(1,tab.cell_volume);
tmp_array(:,7)=cat(1,tab.cell_surface_area);
tmp_array(:,8)=cat(1,tab.cell_surface_area_over_volume);
tmp_array(:,9)=cat(1,tab.nucleoid_length);
tmp_array(:,10)=cat(1,tab.nucleoid_width);
tmp_array(:,11)=cat(1,tab.nucleoid_area);
tmp_array(:,12)=cat(1,tab.nucleoid_volume);
tmp_array(:,13)=cat(1,tab.NC_ratio);
tmp_array(:,14)=cat(1,tab.rel_nucleoid_pos);
tmp_array(:,15)=cat(1,tab.number_of_nucleoids);
tmp_array(:,16)=cat(1,tab.nucleoid_length_ratio);
tmp_array(:,17)=cat(1,tab.nucleoid_width_ratio);
tmp_array(:,18)=cat(1,tab.nucleoid_area_ratio);
tmp_array(:,19)=cat(1,tab.nucleoid_volume_ratio);
tmp_array(:,20)=cat(1,tab.rel_pos_nucleoid1);
tmp_array(:,21)=cat(1,tab.rel_pos_nucleoid2);
tmp_array(:,22)=cat(1,tab.cell_constr);
tmp_array(:,23)=cat(1,tab.cell_constr_pos);
tmp_array(:,24)=cat(1,tab.nucleoid_constr);
tmp_array(:,25)=cat(1,tab.nucleoid_constr_pos);
tmp_array(:,26)=cat(1,tab.rel_cell_constr);
tmp_array(:,27)=cat(1,tab.rel_nucleoid_constr);
tmp_array(:,28)=cat(1,tab.total_PA_int);
tmp_array(:,29)=cat(1,tab.total_PA_conc);
tmp_array(:,30)=cat(1,tab.orientation);
tmp_array(:,31)=cat(1,tab.local_PA_int);
tmp_array(:,32)=cat(1,tab.local_PA_conc);
tmp_array(:,33)=cat(1,tab.minDist);
tmp_array(:,34)=cat(1,tab.signal1_peak);


%Write output array
cell_properties=tmp_array;

end

function d=edist(x1,y1,x2,y2)
%{
-About-
Function that caculates euclidean distance between 2 points

-Inputs-
x1: x-coordinate of first point
y1: y-coordinate of first point
x2: x-coordinate of second point
y2: y-coordinate of second point

-Author-
Sander Govers
%}    
    d=sqrt((x2-x1).^2+(y2-y1).^2);
end